# 项目名称：孟宪聪项目报告（第 1 周）

## 1. 代码链接
- **GitHub 仓库地址**：https://github.com/Anci-057/proj1
- **代码结构说明**：  

```c
project-root/
├── src/               # 源代码目录
│   ├── main.cpp       # 主程序入口
│   ├── db/            # 数据库操作
│   │   └── database.cpp  # 数据库操作代码
│   ├── hash/          # 哈希计算
│   │   └── hash.cpp   # 哈希计算代码（SHA-256）
│   └── utils/         # 工具函数模块
│       └── utils.cpp  # 辅助函数
├── include/           # 头文件
│   ├── database.h     # 数据库操作头文件
│   ├── hash.h         # 哈希计算头文件
│   └── utils.h        # 工具函数头文件
├── lib/               # 动态库静态库
│   └── libsqlite3.a   # SQLite 静态库（如使用）
├── docs/              # 文档目录
│   └── project_description.md # 项目说明文档
├── Makefile           # 自动编译文件
└── README.md          # 项目说明

```

---

## 2. 完成的功能截图
## 1. 首次项目目标

你需要设计并实现一个 **用户验证系统**，该系统使用 **SQLite** 数据库存储用户数据，并通过 **哈希算法** 来验证用户的身份。具体要求包括：

- 使用盐值 (`salt`) 和密码生成哈希值。
- 使用 `SHA-256` 哈希算法来对密码进行加密。
- 使用 SQLite 存储用户数据，包括用户名、盐值和哈希值。
- 通过比对用户输入的密码的哈希值与存储的哈希值来验证用户身份。

---

## 2. 实现的功能

### 2.1 数据库管理 (SQLite)

- **创建数据库和表**：你创建了一个 SQLite 数据库 `user_data.db`，并在其中创建了一个 `users` 表，存储用户名、盐值和哈希值。

- **插入示例用户**：你插入了一个示例用户 `testuser`，并为其提供了盐值 `randomsalt123` 和示例哈希值 `dummyhash12345`。你通过手动或程序生成了这些哈希值。

---

### 2.2 哈希计算 (SHA-256)

- **生成哈希值**：你通过 C++ 编写的程序，使用 `SHA-256` 算法计算了用户输入的密码和盐值的哈希值。

- 你使用了 OpenSSL 库来执行 SHA-256 哈希计算。

- 你成功生成了从 `password123` 和 `randomsalt123` 拼接后的哈希值。

---

### 2.3 用户验证系统

- **验证用户身份**：通过输入用户名和密码，程序查询数据库并从 `users` 表中获取对应的盐值和哈希值。

- **比较哈希值**：程序将计算输入的密码和盐值拼接后的哈希值，并与存储在数据库中的哈希值进行比较。若哈希值匹配，则验证通过，用户登录成功；否则，验证失败。

---

### 2.4 SQLite 数据库操作

- **更新哈希值**：为了确保正确的哈希值匹配，你成功地将生成的哈希值更新到 `users` 表中的 `testuser` 用户记录中。

- **查询数据库**：你使用了 SQLite 查询来查看和验证数据库中的用户数据，确保插入和更新操作正确。

---

### 2.5 程序运行结果

通过运行 C++ 程序，你能够输入用户名和密码，系统会计算哈希并与数据库中存储的哈希值进行匹配。

- 如果用户名和密码正确匹配，系统输出 `"Login successful!"`；否则，输出 `"Invalid username or password!"`。

---

## 3. 总结

你已经完成了以下功能：

- 使用 SQLite 管理用户数据（用户名、盐值、哈希值）。
- 使用 SHA-256 算法对用户密码进行哈希计算。
- 完成了用户身份验证，比较计算出的哈希值与数据库中的哈希值。
- 通过程序进行哈希值更新、验证和查询数据库。

---

## 4. 后续优化建议

- **密码保护**：当前系统只使用了 SHA-256，可以考虑使用更强的加密算法或多次哈希（例如，加盐的 bcrypt）来增强安全性。
- **错误处理**：可以进一步增强错误处理，捕获数据库错误或哈希计算中的潜在问题。
- **扩展功能**：例如添加注册功能，允许新用户创建账户，并将其用户名、盐值和哈希值插入数据库。

## 功能实现情况
包括数据集测试，哈希值测试，和登录验证测试
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6f9bef4889fc4b3a975b1da571dee73e.png)
代码内容：

```c
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT NOT NULL UNIQUE,
    salt TEXT NOT NULL,
    hash TEXT NOT NULL
);
INSERT INTO users (username, salt, hash)
VALUES ('testuser', 'randomsalt123', 'dummyhash12345');
UPDATE users
SET hash = '4360840e947348eac05db1dec2ef42f14f412e56019bc05c738d8c9141908334'
WHERE username = 'testuser';


```
C++ 代码

```c
// 生成 SHA-256 哈希
std::string generateHash(const std::string &password, const std::string &salt) {
    std::string saltedPassword = salt + password;
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256_CTX sha256;
    SHA256_Init(&sha256);
    SHA256_Update(&sha256, saltedPassword.c_str(), saltedPassword.length());
    SHA256_Final(hash, &sha256);

    char hexHash[65];
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(hexHash + (i * 2), "%02x", hash[i]);
    }
    hexHash[64] = 0;
    return std::string(hexHash);
}

```

```c
bool verifyUser(const std::string &username, const std::string &password) {
    sqlite3 *db;
    sqlite3_stmt *stmt;
    const char *sql = "SELECT salt, hash FROM users WHERE username = ?;";

    // 打开数据库
    if (sqlite3_open("user_data.db", &db)) {
        std::cerr << "Can't open database: " << sqlite3_errmsg(db) << std::endl;
        return false;
    }

    // 准备 SQL 语句
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, 0) != SQLITE_OK) {
        std::cerr << "Failed to fetch data: " << sqlite3_errmsg(db) << std::endl;
        sqlite3_close(db);
        return false;
    }

    // 绑定用户名参数
    sqlite3_bind_text(stmt, 1, username.c_str(), -1, SQLITE_STATIC);

    // 执行 SQL 查询并检查结果
    int result = sqlite3_step(stmt);
    if (result == SQLITE_ROW) {
        std::string salt = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));
        std::string storedHash = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1));

        // 验证哈希值
        std::string generatedHash = generateHash(password, salt);
        if (generatedHash == storedHash) {
            sqlite3_finalize(stmt);
            sqlite3_close(db);
            return true; // 登录成功
        }
    }

    sqlite3_finalize(stmt);
    sqlite3_close(db);
    return false; // 登录失败
}

```

```c
int main() {
    std::string username, password;
    std::cout << "Enter username: ";
    std::cin >> username;
    std::cout << "Enter password: ";
    std::cin >> password;

    if (verifyUser(username, password)) {
        std::cout << "Login successful!" << std::endl;
    } else {
        std::cout << "Invalid username or password!" << std::endl;
    }

    return 0;
}

```
生成 SHA-256 哈希的 C++ 程序

```c
#include <iostream>
#include <openssl/sha.h>

// 生成 SHA-256 哈希
std::string generateHash(const std::string &password, const std::string &salt) {
    std::string saltedPassword = salt + password;
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256_CTX sha256;
    SHA256_Init(&sha256);
    SHA256_Update(&sha256, saltedPassword.c_str(), saltedPassword.length());
    SHA256_Final(hash, &sha256);

    char hexHash[65];
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(hexHash + (i * 2), "%02x", hash[i]);
    }
    hexHash[64] = 0;
    return std::string(hexHash);
}

int main() {
    std::string password = "password123";
    std::string salt = "randomsalt123";

    std::string hash = generateHash(password, salt);
    std::cout << "Generated hash: " << hash << std::endl;

    return 0;
}

```
## 第一次试验遇到的问题和解决方案

### 1. 问题：数据库中的哈希值不匹配

#### 1.1 问题描述
在进行用户验证时，程序提示 `"Invalid username or password!"`，说明生成的哈希值与数据库中存储的哈希值不匹配。

#### 1.2 解决方案
- **确认哈希计算算法**：检查程序中使用的哈希算法（SHA-256）与数据库中插入的哈希值是否一致。特别是，确认 `password123` 和 `randomsalt123` 的哈希计算是否正确。
- **解决方法**：
  - 编写一个单独的程序来生成 `password123` 和 `randomsalt123` 拼接后的哈希值，并手动将正确的哈希值更新到 SQLite 数据库。
  - 运行 C++ 程序来验证哈希值是否匹配，并确保哈希算法的实现（如使用 OpenSSL 库计算 SHA-256）没有错误。

#### 1.3 相关代码
生成哈希值的 C++ 代码：
```cpp
std::string generateHash(const std::string &password, const std::string &salt) {
    std::string saltedPassword = salt + password;
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256_CTX sha256;
    SHA256_Init(&sha256);
    SHA256_Update(&sha256, saltedPassword.c_str(), saltedPassword.length());
    SHA256_Final(hash, &sha256);

    char hexHash[65];
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(hexHash + (i * 2), "%02x", hash[i]);
    }
    hexHash[64] = 0;
    return std::string(hexHash);
}


```
### 问题：无法正确更新 SQLite 数据库中的哈希值

#### 问题描述
在 SQLite 数据库中更新哈希值时，尝试将新的哈希值插入时出现问题，导致哈希值未更新或验证失败。

#### 解决方案
- **检查 SQL 语法和数据库连接**：确认使用的 SQL 语法正确，且与 SQLite 数据库建立了有效的连接。确保插入或更新操作时，SQL 语句执行成功且没有报错。
  
- **手动插入和更新数据**：通过 SQLite 命令行工具手动更新用户的哈希值，确保数据库中存储的哈希值与程序计算的哈希值一致。可以使用 SQLite 查询命令来确认数据是否已成功更新。

- **确保哈希值匹配**：在更新数据库之前，确保你计算的哈希值和数据库中的哈希值完全匹配。可以使用程序生成哈希值，然后通过查询工具验证是否正确存储。

####  相关操作
- 使用 SQLite 工具检查数据库内容。
- 手动通过 SQLite 命令行插入或更新哈希值，确保数据一致。

